<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pasteboard with Readable Clips</title>
<style>
body {
  font-family: system-ui, Segoe UI, Arial;
  margin: 20px;
  color: #222;
}
h1 { font-size: 22px; margin-bottom: 8px; }
#instructions {
  font-size: 1.2em;
  color: #666;
  margin-bottom: 12px;
}
#output {
  margin-top: 14px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.img-wrap {
  position: relative;
  display: inline-block;
  border-radius: 8px;
  padding: 4px;
  border: 1px solid #ddd;
}
.img-wrap:focus {
  outline: 3px solid #4a90e280;
}
/* Description */
.desc {
  font-size: 1.2em;
  margin-bottom: 4px;
  padding: 2px 4px;
  min-height: 20px;
  border-radius: 4px;
  outline: none;
  background: #f9f9f9;
  border: 1px solid #e0e0e0;
}
.desc:focus {
  border-color: #4a90e2;
  background: #f0f6ff;
  cursor: text;
}
/* Drag handle */
.drag-handle {
  cursor: grab;
  user-select: none;
  display: inline-block;
  padding: 2px 6px;
  font-weight: bold;
  color: #666;
  margin-bottom: 4px;
}
.drag-handle:active { cursor: grabbing; }
/* Resize handles */
.resize-handle {
  position: absolute;
  width: 12px;
  height: 12px;
  background: #4a90e2;
  border-radius: 2px;
}
.resize-se {
  right: 2px;
  bottom: 2px;
  cursor: se-resize;
}
.resize-sw {
  left: 2px;
  bottom: 2px;
  cursor: sw-resize;
}
/* Hover delete button */
.delete-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(0,0,0,0.65);
  color: white;
  border: none;
  cursor: pointer;
  font-size: 16px;
  display: none;
  z-index: 10;
}
.img-wrap:hover .delete-btn {
  display: block;
}
/* Drag indicators */
.insert-before { border-top: 3px solid #4a90e2; }
.insert-after  { border-bottom: 3px solid #4a90e2; }
/* Toolbar */
#toolbar {
  margin-top: 14px;
  display: flex;
  gap: 10px;
}
button {
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-radius: 6px;
  cursor: pointer;
  background: #fff;
}
#status {
  margin-top: 8px;
  font-size: 13px;
  color: #555;
}
</style>
</head>
<body>
<h1>Pasteboard with Readable Clips</h1>
<div id="instructions">
Press <strong>Ctrl+V</strong> anywhere to paste screenshots. <strong>Clips are pasted at a default size for readability; only use resizing handles for very large images.</strong> Click an image to focus → type a description above it. Use the drag handle ☰ to reorder. Use the resize handles at the bottom corners to adjust size (right corner = enlarge, left corner = shrink). Press <strong>Delete</strong> to remove.
</div>
<div id="toolbar">
  <button id="copyAllBtn">Copy All (stacked PNG)</button>
  <button id="clearBtn">Clear All</button>
  <button id="resetBtn">Reset Collection</button>
</div>
<div id="status"></div>
<div id="output"></div>
<script>
(() => {
const output = document.getElementById("output");
const status = document.getElementById("status");
let dragSrcEl = null;
let saveTimeout = null;

function log(msg, err=false){
  status.textContent = msg;
  status.style.color = err ? "#b22" : "#555";
}

function saveCollection(){
  try {
    const wraps = [...document.querySelectorAll(".img-wrap")];
    const items = wraps.map(wrap => {
      const img = wrap.querySelector("img");
      const desc = wrap.querySelector(".desc");
      return {
        src: img.src,
        width: img.style.width || 'auto',
        height: img.style.height || 'auto',
        desc: desc.textContent
      };
    });
    localStorage.setItem('clipboard-collection', JSON.stringify(items));
    console.log('✓ Collection saved:', items.length, 'items');
  } catch(e) {
    console.error('✗ Save failed:', e);
  }
}

function scheduleSave(){
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(saveCollection, 500);
}

/* Add image and return the wrap element */
function addImage(dataURL, props={}) {
  const wrap = document.createElement("div");
  wrap.className = "img-wrap";
  wrap.setAttribute("tabindex", "0");

  // Description
  const desc = document.createElement("div");
  desc.className = "desc";
  desc.setAttribute("contenteditable","true");
  desc.textContent = props.desc || "";
  desc.addEventListener('mousedown', e => e.stopPropagation());
  desc.addEventListener('click', e => e.stopPropagation());
  desc.addEventListener('pointerdown', e => e.stopPropagation());
  desc.addEventListener('input', scheduleSave);

  // Drag handle
  const handle = document.createElement("div");
  handle.className = "drag-handle";
  handle.setAttribute("draggable","true");
  handle.textContent = "☰";

  // Image
  const img = document.createElement("img");
  img.src = dataURL;
  img.style.width = props.width || "auto";
  img.style.height = props.height || "auto";
  img.style.maxWidth = "90vw";

  // Delete button
  const del = document.createElement("button");
  del.className = "delete-btn";
  del.textContent = "×";
  del.onclick = e => { e.stopPropagation(); wrap.remove(); scheduleSave(); };

  // Resize handles
  const resizeSE = document.createElement("div");
  resizeSE.className = "resize-handle resize-se";
  const resizeSW = document.createElement("div");
  resizeSW.className = "resize-handle resize-sw";

  // Resize logic
  function resizeHandler(e, isSE){
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startWidth = img.offsetWidth;
    const startHeight = img.offsetHeight;
    function onMouseMove(ev){
      let newWidth = isSE ? startWidth + (ev.clientX - startX) : startWidth - (ev.clientX - startX);
      newWidth = Math.max(50,newWidth);
      const newHeight = startHeight * (newWidth/startWidth);
      img.style.width = newWidth + 'px';
      img.style.height = newHeight + 'px';
    }
    function onMouseUp(){
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      scheduleSave();
    }
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }
  resizeSE.addEventListener('mousedown', e=>resizeHandler(e,true));
  resizeSW.addEventListener('mousedown', e=>resizeHandler(e,false));

  wrap.append(desc, handle, img, resizeSE, resizeSW, del);
  output.appendChild(wrap);
  wrap.onclick = () => wrap.focus();

  /* Dragging via handle only */
  handle.addEventListener("dragstart", e => {
    dragSrcEl = wrap;
    e.dataTransfer.effectAllowed = "move";
  });
  wrap.addEventListener("dragover", e => {
    e.preventDefault();
    const rect = wrap.getBoundingClientRect();
    const y = e.clientY - rect.top;
    wrap.classList.remove("insert-before","insert-after");
    if(y < rect.height/2) wrap.classList.add("insert-before");
    else wrap.classList.add("insert-after");
  });
  wrap.addEventListener("dragleave", ()=>wrap.classList.remove("insert-before","insert-after"));
  wrap.addEventListener("drop", e=>{
    e.preventDefault();
    wrap.classList.remove("insert-before","insert-after");
    if(!dragSrcEl || dragSrcEl===wrap) return;
    const rect = wrap.getBoundingClientRect();
    const y = e.clientY - rect.top;
    if(y<rect.height/2) output.insertBefore(dragSrcEl,wrap);
    else output.insertBefore(dragSrcEl,wrap.nextSibling);
    scheduleSave();
  });

  log("Image added.");
  return wrap;
}

/* Handle clipboard blob */
function handleBlob(blob){
  const reader = new FileReader();
  reader.onload = ev => { addImage(ev.target.result); scheduleSave(); };
  reader.readAsDataURL(blob);
}

/* Paste images */
document.addEventListener("paste", e=>{
  const items = e.clipboardData.items;
  for(const it of items){
    if(it.type.startsWith("image")){
      const file = it.getAsFile();
      if(file) handleBlob(file);
      e.preventDefault();
      return;
    }
  }
  log("Clipboard contains no image.", true);
});

/* Delete via Delete key */
document.addEventListener("keydown", e=>{
  if(e.key==="Delete"){
    const focused = document.activeElement;
    if(focused && focused.classList.contains("img-wrap")){
      focused.remove();
      scheduleSave();
      log("Image deleted.");
    }
  }
});

/* Toolbar buttons */
document.getElementById("clearBtn").onclick = ()=>{ output.innerHTML=""; scheduleSave(); log("All cleared."); };
document.getElementById("resetBtn").onclick = ()=>{
  if(confirm("This will permanently delete your saved collection. Are you sure?")){
    output.innerHTML = "";
    localStorage.removeItem('clipboard-collection');
    log("Collection reset.");
  }
};

/* Copy all stacked PNG */
document.getElementById("copyAllBtn").onclick = async ()=>{
  const wraps = [...document.querySelectorAll(".img-wrap")];
  if(wraps.length===0){ log("Nothing to copy."); return; }
  let blocks = await Promise.all(wraps.map(wrap=>{
    return new Promise(res=>{
      const img = wrap.querySelector("img");
      const desc = wrap.querySelector(".desc");
      const displayWidth = img.offsetWidth;
      const displayHeight = img.offsetHeight;
      const descText = desc.textContent.trim();
      const im = new Image();
      im.onload = ()=>res({img: im, desc: descText, width: displayWidth, height: displayHeight});
      im.src = img.src;
    });
  }));

  const padding = 20;
  const fontSize = 16;
  const lineHeight = 22;
  let totalHeight = 0;
  let maxWidth = 0;
  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.font = `${fontSize}px system-ui, sans-serif`;

  blocks.forEach(block=>{
    if(block.desc){
      const words = block.desc.split(' ');
      const lines = [];
      let currentLine='';
      words.forEach(word=>{
        const testLine = currentLine ? currentLine+' '+word : word;
        const metrics = tempCtx.measureText(testLine);
        if(metrics.width > block.width - padding*2 && currentLine){
          lines.push(currentLine);
          currentLine = word;
        } else currentLine = testLine;
      });
      if(currentLine) lines.push(currentLine);
      block.textLines = lines;
      block.textHeight = lines.length*lineHeight + padding;
    } else { block.textLines=[]; block.textHeight=0; }
    totalHeight += block.textHeight + block.height + padding;
    maxWidth = Math.max(maxWidth, block.width);
  });
  totalHeight += padding;

  const canvas = document.createElement("canvas");
  canvas.width = maxWidth;
  canvas.height = totalHeight;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.font = `${fontSize}px system-ui, sans-serif`;
  ctx.fillStyle = "#000000";

  let y = padding;
  blocks.forEach(block=>{
    if(block.textLines.length>0) block.textLines.forEach((line,i)=>ctx.fillText(line,padding,y+(i+1)*lineHeight));
    y += block.textHeight;
    ctx.drawImage(block.img,0,y,block.width,block.height);
    y += block.height + padding;
  });

  try{
    let blob = await new Promise(r=>canvas.toBlob(r,"image/png"));
    await navigator.clipboard.write([new ClipboardItem({"image/png": blob})]);
    log("Copied all images with descriptions as one PNG.");
  }catch(e){
    log("Copy failed — browser blocked image clipboard write.", true);
  }
};

/* Load saved collection synchronously */
function loadCollection(){
  try {
    const saved = localStorage.getItem('clipboard-collection');
    if(saved){
      const items = JSON.parse(saved);
      console.log('Loading', items.length, 'items');
      items.forEach(item => addImage(item.src, {width:item.width, height:item.height, desc:item.desc}));
      log(`Restored ${items.length} saved clip(s).`);
    } else {
      log("Ready — paste images with Ctrl+V, add descriptions, resize, and reorder.");
    }
  } catch(e){
    console.error('Load failed:', e);
    log("Ready — paste images with Ctrl+V, add descriptions, resize, and reorder.");
  }
}

if(document.readyState==='loading'){
  document.addEventListener('DOMContentLoaded', loadCollection);
} else loadCollection();
})();
</script>
</body>
</html>



