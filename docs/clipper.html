<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Clipboard Win</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úÇÔ∏è</text></svg>">
<style>
* { box-sizing: border-box; }
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  margin: 0;
  padding: 20px;
  background: #f3f4f6;
  min-height: 100vh;
  color: #1a1a2e;
}
.container {
  max-width: 1400px;
  margin: 0 auto;
}
header {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 24px 32px;
  margin-bottom: 24px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
h1 { 
  font-size: 28px;
  margin: 0 0 12px 0;
  font-weight: 600;
  color: #1f2937;
}
#instructions { 
  font-size: 15px;
  color: #4a5568;
  line-height: 1.6;
  margin: 0;
}
#instructions strong {
  color: #2d3748;
  font-weight: 600;
}
#toolbar { 
  display: flex;
  gap: 12px;
  margin-top: 20px;
  flex-wrap: wrap;
}
button { 
  padding: 10px 20px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  cursor: pointer;
  background: white;
  color: #374151;
  font-weight: 500;
  font-size: 14px;
  transition: all 0.15s ease;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
button:hover {
  background: #f9fafb;
  border-color: #9ca3af;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
button:active {
  transform: translateY(0);
  background: #f3f4f6;
}
#clearBtn {
  background: #fef2f2;
  color: #dc2626;
  border-color: #fecaca;
}
#clearBtn:hover {
  background: #fee2e2;
  border-color: #fca5a5;
}
#status { 
  margin-top: 12px;
  font-size: 14px;
  color: #2d3748;
  padding: 8px 12px;
  background: rgba(255,255,255,0.5);
  border-radius: 8px;
  display: inline-block;
  transition: all 0.3s ease;
}
#output { 
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-top: 24px;
}
.img-wrap { 
  position: relative;
  background: white;
  border-radius: 8px;
  padding: 16px;
  border: 1px solid #e5e7eb;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: all 0.15s ease;
  cursor: pointer;
}
.img-wrap:hover {
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  border-color: #d1d5db;
}
.img-wrap:focus { 
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
.img-wrap.dragging {
  opacity: 0.5;
  transform: scale(0.95);
}
.desc { 
  font-size: 14px;
  margin-bottom: 12px;
  padding: 8px 12px;
  min-height: 36px;
  border-radius: 6px;
  outline: none;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  transition: all 0.15s ease;
  color: #374151;
}
.desc:focus { 
  border-color: #3b82f6;
  background: white;
  cursor: text;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
.desc:empty:before {
  content: "Add description...";
  color: #a0aec0;
}
.drag-handle { 
  cursor: grab;
  user-select: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 4px 10px;
  font-weight: 500;
  color: #6b7280;
  margin-bottom: 8px;
  font-size: 16px;
  border-radius: 4px;
  background: #f3f4f6;
  transition: all 0.15s ease;
}
.drag-handle:hover {
  background: #e5e7eb;
  color: #374151;
}
.drag-handle:active { 
  cursor: grabbing;
  transform: scale(0.95);
}
.img-container {
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  background: #f7fafc;
  display: flex;
  align-items: center;
  justify-content: center;
}
.annotation-canvas {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}
.annotation-toolbar {
  display: flex;
  gap: 6px;
  margin-top: 8px;
  padding: 8px;
  background: #f9fafb;
  border-radius: 6px;
  border: 1px solid #e5e7eb;
  flex-wrap: wrap;
  align-items: center;
}
.annotation-toolbar button {
  padding: 6px 12px;
  font-size: 13px;
  min-width: 60px;
}
.annotation-toolbar button.active {
  background: #3b82f6;
  color: white;
  border-color: #2563eb;
}
.annotation-toolbar input[type="color"] {
  width: 40px;
  height: 32px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  cursor: pointer;
  padding: 2px;
}
.annotation-toolbar input[type="number"] {
  width: 60px;
  padding: 6px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 13px;
}
.annotation-toolbar label {
  font-size: 12px;
  color: #6b7280;
  margin-left: 4px;
}
.img-container img {
  display: block;
  max-width: 100%;
  height: auto;
}
.resize-handle { 
  position: absolute;
  width: 14px;
  height: 14px;
  background: #3b82f6;
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.15s ease;
  z-index: 5;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.img-wrap:hover .resize-handle {
  opacity: 1;
}
.resize-se { 
  right: 4px;
  bottom: 4px;
  cursor: se-resize;
}
.resize-sw { 
  left: 4px;
  bottom: 4px;
  cursor: sw-resize;
}
.delete-btn { 
  position: absolute;
  top: 12px;
  right: 12px;
  width: 28px;
  height: 28px;
  border-radius: 4px;
  background: #dc2626;
  color: white;
  border: none;
  cursor: pointer;
  font-size: 18px;
  font-weight: bold;
  opacity: 0;
  transition: all 0.15s ease;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.img-wrap:hover .delete-btn { 
  opacity: 1;
}
.delete-btn:hover {
  background: #b91c1c;
  transform: scale(1.05);
}
.insert-before { 
  border-top: 2px solid #3b82f6;
}
.insert-after { 
  border-bottom: 2px solid #3b82f6;
}
.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: #6b7280;
  font-size: 16px;
}
.empty-state-icon {
  font-size: 48px;
  margin-bottom: 12px;
  opacity: 0.5;
}
@media (max-width: 768px) {
  #output {
    grid-template-columns: 1fr;
  }
  
  header {
    padding: 20px;
  }
  
  h1 {
    font-size: 24px;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>‚úÇÔ∏è Clipboard Win</h1>
    <div id="instructions">
      Press <strong>Ctrl+V</strong> anywhere to paste screenshots. Click an image to add a description. 
      Use the <strong>‚ò∞ handle</strong> to reorder clips. Use corner handles to resize (right = larger, left = smaller). <strong> Use resizing only</strong> for really wide clips.   
      Use <strong>üé® tools</strong> to add arrows and text to images. Press <strong>Delete</strong> to remove focused clips.
    </div>
    <div id="toolbar">
      <button id="copyAllBtn">üìã Copy All as PNG</button>
      <button id="saveBtn">üíæ Save as PNG File</button>
      <button id="clearBtn">üóëÔ∏è Clear All</button>
    </div>
    <div id="status">Ready ‚Äî Paste images to begin</div>
  </header>
  
  <div id="output">
    <div class="empty-state">
      <div class="empty-state-icon">üì∏</div>
      <div>Paste your first screenshot to get started</div>
    </div>
  </div>
</div>
<script>
(() => {
const output = document.getElementById("output");
const status = document.getElementById("status");
let dragSrcEl = null;
let saveTimeout = null;
function log(msg, err=false){ 
  status.textContent = msg; 
  status.style.color = err ? "#e53e3e" : "#2d3748";
  status.style.background = err ? "rgba(254, 215, 215, 0.8)" : "rgba(255,255,255,0.5)";
}
function saveCollection(){ 
  try { 
    const wraps = [...document.querySelectorAll(".img-wrap")]; 
    const items = wraps.map(wrap => { 
      const img = wrap.querySelector("img"); 
      const desc = wrap.querySelector(".desc"); 
      const canvas = wrap.querySelector(".annotation-canvas");
      return { 
        src: img.src, 
        width: img.style.width || 'auto', 
        height: img.style.height || 'auto', 
        desc: desc.textContent,
        annotations: canvas.annotations || []
      }; 
    }); 
    localStorage.setItem('clipboard-collection', JSON.stringify(items)); 
    console.log('‚úì Collection saved:', items.length, 'items'); 
  } catch(e) { 
    console.error('‚úó Save failed:', e); 
  }
}
function scheduleSave(){ 
  const canvas = document.createElement("canvas");
  canvas.className = "annotation-canvas";
  
  imgContainer.appendChild(img);
  imgContainer.appendChild(canvas
  saveTimeout = setTimeout(saveCollection, 500);
}
function updateEmptyState() {
  const emptyState = output.querySelector('.empty-state');
  const hasClips = output.querySelectorAll('.img-wrap').length > 0;
  
  if (hasClips && emptyState) {
    emptyState.remove();
  } else if (!hasClips && !emptyState) {
    const empty = document.createElement('div');
    empty.className = 'empty-state';
    empty.innerHTML = `
      <div class="empty-state-icon">üì∏</div>
      <div>Paste your first screenshot to get started</div>
    `;
    output.appendChild(empty);
  }
}
function addImage(dataURL, props={}) { 
  const wrap = document.createElement("div"); 
  wrap.className = "img-wrap"; 
  wrap.setAttribute("tabindex", "0");
  
  const desc = document.createElement("div"); 
  desc.className = "desc"; 
  desc.setAttribute("contenteditable","true"); 
  desc.textContent = props.desc || ""; 
  desc.addEventListener('mousedown', e => e.stopPropagation()); 
  desc.addEventListener('click', e => e.stopPropagation()); 
  desc.addEventListener('pointerdown', e => e.stopPropagation()); 
  desc.addEventListener('input', scheduleSave);
  
  const handle = document.createElement("div"); 
  handle.className = "drag-handle"; 
  handle.setAttribute("draggable","true"); 
  handle.textContent = "‚ò∞";
  
  const imgContainer = document.createElement("div");
  imgContainer.className = "img-container";
  
  const img = document.createElement("img"); 
  img.src = dataURL; 
  img.style.width = props.width || "auto"; 
  img.style.height = props.height || "auto"; 
  img.style.maxWidth = "100%";
  
  imgContainer.appendChild(img);
  
  const del = document.createElement("button"); 
  del.className = "delete-btn"; 
  del.textContent = "√ó"; 
  del.onclick = e => { 
    e.stopPropagation(); 
    wrap.remove(); 
    scheduleSave();
    updateEmptyState();
  };
  
  const resizeSE = document.createElement("div"); 
  resizeSE.className = "resize-handle resize-se"; 
  const resizeSW = document.createElement("div"); 
  resizeSW.className = "resize-handle resize-sw";
  img.onload = () => {
    canvas.width = img.offsetWidth;
    canvas.height = img.offsetHeight;
    if (props.annotations) {
      drawAnnotations(canvas, props.annotations);
    }
  };
  
  function resizeHandler(e, isSE){ 
    e.preventDefault(); 
    e.stopPropagation(); 
    const startX = e.clientX; 
    const startWidth = img.offsetWidth; 
    const startHeight = img.offsetHeight; 
    const aspectRatio = startWidth / startHeight;
    const containerMaxWidth = imgContainer.offsetWidth;
    
    function onMouseMove(ev){ 
      let newWidth = isSE ? startWidth + (ev.clientX - startX) : startWidth - (ev.clientX - startX); 
      newWidth = Math.max(50, Math.min(newWidth, containerMaxWidth)); 
      const newHeight = newWidth / aspectRatio;
      img.style.width = newWidth + 'px'; 
      img.style.height = newHeight + 'px';
      canvas.width = newWidth;
      canvas.height = newHeight;
      redrawAnnotations(canvas);
    } 
    
    function onMouseUp(){ 
      document.removeEventListener('mousemove', onMouseMove); 
      document.removeEventListener('mouseup', onMouseUp); 
      scheduleSave(); 
    } 
    
    document.addEventListener('mousemove', onMouseMove); 
    document.addEventListener('mouseup', onMouseUp); 
  } 
  
  resizeSE.addEventListener('mousedown', e=>resizeHandler(e,true)); 
  resizeSW.addEventListener('mousedown', e=>resizeHandler(e,false));
  
  const toolbar = createAnnotationToolbar(canvas, imgContainer);
  
  wrap.append(desc, handle, imgContainer, toolba
  resizeSE.addEventListener('mousedown', e=>resizeHandler(e,true)); 
  resizeSW.addEventListener('mousedown', e=>resizeHandler(e,false));
  
  wrap.append(desc, handle, imgContainer, del); 
  output.appendChild(wrap); 
  
  wrap.onclick = () => wrap.focus();
  
  handle.addEventListener("dragstart", e => { 
    dragSrcEl = wrap; 
    wrap.classList.add('dragging');
    e.dataTransfer.effectAllowed = "move"; 
  });
  
  handle.addEventListener("dragend", () => {
    wrap.classList.remove('dragging');
  });
  
  wrap.addEventListener("dragover", e => { 
    e.preventDefault(); 
    const rect = wrap.getBoundingClientRect(); 
    const y = e.clientY - rect.top; 
    wrap.classList.remove("insert-before","insert-after"); 
    if(y < rect.height/2) wrap.classList.add("insert-before"); 
    else wrap.classList.add("insert-after"); 
  });
  
  wrap.addEventListener("dragleave", ()=>wrap.classList.remove("insert-before","insert-after"));
  
  wrap.addEventListener("drop", e=>{ 
    e.preventDefault(); 
    wrap.classList.remove("insert-before","insert-after"); 
    if(!dragSrcEl || dragSrcEl===wrap) return; 
    const rect = wrap.getBoundingClientRect(); 
    const y = e.clientY - rect.top; 
    if(y<rect.height/2) output.insertBefore(dragSrcEl,wrap); 
    else output.insertBefore(dragSrcEl,wrap.nextSibling); 
    scheduleSave(); 
  });
  
  log("Image added ‚Äî click to add description");
  updateEmptyState();
  return wrap;
}
function handleBlob(blob){ 
  const reader = new FileReader(); 
  reader.onload = ev => { 
    addImage(ev.target.result); 
    scheduleSave(); 
  }; 
  reader.readAsDataURL(blob);
}
document.addEventListener("paste", e=>{ 
  const items = e.clipboardData.items; 
  for(const it of items){ 
    if(it.type.startsWith("image")){ 
      const file = it.getAsFile(); 
      if(file) handleBlob(file); 
      e.preventDefault(); 
      return; 
    } 
  } 
  log("Clipboard contains no image", true);
});
document.addEventListener("keydown", e=>{ 
  if(e.key==="Delete"){ 
    const focused = document.activeElement; 
    if(focused && focused.classList.contains("img-wrap")){ 
      focused.remove(); 
      scheduleSave(); 
      log("Image deleted"); 
      updateEmptyState();
    } 
  }
});
document.getElementById("clearBtn").onclick = ()=>{ 
  output.innerHTML=""; 
  scheduleSave(); 
  log("All clips cleared");
  updateEmptyState();
};
document.getElementById("copyAllBtn").onclick = async ()=>{ 
  const canvas = await generateStackedCanvas(); 
  if(!canvas) return; 
  try{ 
    let blob = await new Promise(r=>canvas.toBlob(r,"image/png")); 
    await navigator.clipboard.write([new ClipboardItem({"image/png": blob})]); 
    log("‚úì Copied all clips as single PNG"); 
  }catch(e){ 
    log("Copy failed ‚Äî browser blocked clipboard access", true); 
  }
};
document.getElementById("saveBtn").onclick = async ()=>{ 
  const canvas = await generateStackedCanvas(); 
  if(!canvas) return; 
  
  if('showSaveFilePicker' in window){ 
    try{ 
      const handle = await window.showSaveFilePicker({ 
        suggestedName: `Clipboard-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`, 
        types: [{ description: 'PNG Image', accept: {'image/png': ['.png']} }] 
      }); 
      const writable = await handle.createWritable(); 
      canvas.toBlob(async blob=>{ 
        await writable.write(blob); 
        await writable.close(); 
        log("‚úì PNG file saved"); 
      },"image/png"); 
    }catch(e){ 
      if(e.name !== 'AbortError') log("Save cancelled", true); 
    } 
  } else { 
    canvas.toBlob(blob=>{ 
      const url = URL.createObjectURL(blob); 
      const a = document.createElement('a'); 
      a.href = url; 
      a.download = `Clipboard-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`; 
      a.click(); 
      URL.revokeObjectURL(url); 
      log("‚úìcanvas = wrap.querySelector(".annotation-canvas");
      const displayWidth = img.offsetWidth; 
      const displayHeight = img.offsetHeight; 
      const descText = desc.textContent.trim(); 
      const im = new Image(); 
      im.onload = ()=>res({img: im, desc: descText, width: displayWidth, height: displayHeight, canvas: canvas
  const wraps = [...document.querySelectorAll(".img-wrap")]; 
  if(wraps.length===0){ 
    log("Nothing to save"); 
    return null; 
  } 
  
  let blocks = await Promise.all(wraps.map(wrap=>{ 
    return new Promise(res=>{ 
      const img = wrap.querySelector("img"); 
      const desc = wrap.querySelector(".desc"); 
      const displayWidth = img.offsetWidth; 
      const displayHeight = img.offsetHeight; 
      const descText = desc.textContent.trim(); 
      const im = new Image(); 
      im.onload = ()=>res({img: im, desc: descText, width: displayWidth, height: displayHeight}); 
      im.src = img.src; 
    }); 
  })); 
  
  const padding = 20; 
  const fontSize = 16; 
  const lineHeight = 22; 
  let totalHeight = 0; 
  let maxWidth = 0; 
  
  const tempCanvas = document.createElement("canvas"); 
  const tempCtx = tempCanvas.getContext("2d"); 
  tempCtx.font = `${fontSize}px system-ui, sans-serif`; 
  
  blocks.forEach(block=>{ 
    if(block.desc){ 
      const words = block.desc.split(' '); 
      const lines = []; 
      let currentLine=''; 
      words.forEach(word=>{ 
        const testLine = currentLine ? currentLine+' '+word : word; 
        const metrics = tempCtx.measureText(testLine); 
        if(metrics.width > block.width - padding*2 && currentLine){ 
          lines.push(currentLine); 
          currentLine = word; 
        } else currentLine = testLine; 
      }); 
      if(currentLine) lines.push(currentLine); 
      block.textLines = lines; 
      block.textHeight = lines.length*lineHeight + padding; 
    } else { 
      block.textLines=[]; 
      block.textHeight=0; 
    } 
    totalHeight += block.textHeight + block.height + padding; 
    maxWidth = Math.max(maxWidth, block.width); 
  }); 
  
  totalHeight += padding; 
  const canvas = document.createElement("canvas"); 
  canvas.width = maxWidth; 
  canvas.height = totalHeight; 
  const ctx = canvas.getContext("2d"); 
  
  ctx.filcreateAnnotationToolbar(canvas, imgContainer) {
  const toolbar = document.createElement("div");
  toolbar.className = "annotation-toolbar";
  
  let currentTool = null;
  let currentColor = "#ff0000";
  let currentLineWidth = 3;
    if(block.canvas && block.canvas.annotations && block.canvas.annotations.length > 0) {
      ctx.save();
      ctx.translate(0, y);
      drawAnnotations({getContext: () => ctx, width: block.width, height: block.height}, block.canvas.annotations);
      ctx.restore();
    }
  let isDrawing = false;
  let startX, startY;
  
  if (!canvas.annotations) canvas.annotations = [];
  
  const arrowBtn = document.createElement("button");
  arrowBtn.textContent = "‚û°Ô∏è Arrow";
  arrowBtn.title = "Click to draw arrows";
  
  const textBtn = document.createElement("button");
  textBtn.textContent = "üìù Text";
  textBtn.title = "Click to add text";
  
  const clearBtn = document.createElement("button");
  clearBtn.textContent = "üóëÔ∏è Clear";
  clearBtn.title = "Clear all annotations";
  
  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = currentColor;
  colorInput.title = "Choose color";
  
  const widthInput = document.createElement("input");
  widthInput.type = "number";
  widthInput.min = "1";
  widthInput.max = "10";
  widthInput.value = currentLineWidth;
  widthInput.title = "Line width";
  
  const widthLabel = document.createElement("label");
  widthLabel.textContent = "Width";
  
  arrowBtn.onclick = (e) => {
    e.stopPropagation();
    currentTool = currentTool === 'arrow' ? null : 'arrow';
    arrowBtn.classList.toggle('active');
    textBtn.classList.remove('active');
    canvas.style.pointerEvents = currentTool ? 'auto' : 'none';
  };
  
  textBtn.onclick = (e) => {
    e.stopPropagation();
    currentTool = currentTool === 'text' ? null : 'text';
    textBtn.classList.toggle('active');
    arrowBtn.classList.remove('active');
    canvas.style.pointerEvents = currentTool ? 'auto' : 'none';
  };
  
  clearBtn.onclick = (e) => {
    e.stopPropagation();
    canvas.annotations = [];
    redrawAnnotations(canvas);
    scheduleSave();
  };
  
  colorInput.oninput = () => {
    currentColor = colorInput.value;
  };
  
  widthInput.oninput = () => {
    currentLineWidth = parseInt(widthInput.value);
  };
  
  canvas.addEventListener('mousedown', (e) => {
    if (!currentTool) return;
    e.preventDefault();
    e.stopPropagation();
    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;
    isDrawing = true;
  });
  
  canvas.addEventListener('mousemove', (e) => {
    if (!isDrawing || !currentTool) return;
    const rect = canvas.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    if (currentTool === 'arrow') {
      redrawAnnotations(canvas);
      const ctx = canvas.getContext('2d');
      drawArrow(ctx, startX, startY, currentX, currentY, currentColor, currentLineWidth);
    }
  });
  
  canvas.addEventListener('mouseup', (e) => {
    if (!isDrawing || !currentTool) return;
    e.stopPropagation();
    const rect = canvas.getBoundingClientRect();
    const endX = e.clientX - rect.left;
    const endY = e.clientY - rect.top;
    
    if (currentTool === 'arrow') {
      canvas.annotations.push({
        type: 'arrow',
        x1: startX,
        y1: startY,
        x2: endX,
        y2: endY,
        color: currentColor,
        lineWidth: currentLineWidth
      });
      redrawAnnotations(canvas);
    } else if (currentTool === 'text') {
      const text = prompt('Enter text:');
      if (text) {
        canvas.annotations.push({
          type: 'text',
          x: endX,
          y: endY,
          text: text,
          color: currentColor,
          fontSize: currentLineWidth * 6
        });
        redrawAnnotations(canvas);
      }
    }
    
    isDrawing = false;
    scheduleSave();
  });
  
  canvas.addEventListener('click', (e) => {
    e.stopPropagation();
  });
  
  toolbar.append(arrowBtn, textBtn, clearBtn, colorInput, widthInput, widthLabel);
  return toolbar;
}

function drawArrow(ctx, x1, y1, x2, y2, color, lineWidth) {
  const headLength = 15 + lineWidth * 2;
  const angle = Math.atan2(y2 - y1, x2 - x1);
  
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round';
  
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6),
             y2 - headLength * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6),
             y2 - headLength * Math.sin(angle + Math.PI / 6));
  ctx.closePath();
  ctx.fill();
}

function drawAnnotations(canvas, annotations) {
  const ctx = canvas.getContext('2d');
  annotations.forEach(ann => {
    if (ann.type === 'arrow') {
      drawArrow(ctx, ann.x1, ann.y1, ann.x2, ann.y2, ann.color, ann.lineWidth);
    } else if (ann.type === 'text') {
      ctx.font = `${ann.fontSize}px sans-serif`;
      ctx.fillStyle = ann.color;
      ctx.fillText(ann.text, ann.x, ann.y);
    }
  });
}

function redrawAnnotations(canvas) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (canvas.annotations) {
    drawAnnotations(canvas, canvas.annotations);
  }
}

function loadCollection(){ 
  try { 
    const saved = localStorage.getItem('clipboard-collection'); 
    if(saved){ 
      const items = JSON.parse(saved); 
      console.log('Loading', items.length, 'items'); 
      items.forEach(item => addImage(item.src, {width:item.width, height:item.height, desc:item.desc, annotations:item.annotations
    if(block.textLines.length>0) block.textLines.forEach((line,i)=>ctx.fillText(line,0,y+(i+1)*lineHeight)); 
    y += block.textHeight; 
    ctx.drawImage(block.img,0,y,block.width,block.height); 
    y += block.height + padding; 
  }); 
  
  return canvas;
}
function loadCollection(){ 
  try { 
    const saved = localStorage.getItem('clipboard-collection'); 
    if(saved){ 
      const items = JSON.parse(saved); 
      console.log('Loading', items.length, 'items'); 
      items.forEach(item => addImage(item.src, {width:item.width, height:item.height, desc:item.desc})); 
      log(`Restored ${items.length} saved clip(s)`); 
    } else { 
      log("Ready ‚Äî Paste images to begin"); 
    } 
  } catch(e){ 
    console.error('Load failed:', e); 
    log("Ready ‚Äî Paste images to begin"); 
  }
  updateEmptyState();
}
if(document.readyState==='loading'){ 
  document.addEventListener('DOMContentLoaded', loadCollection);
} else loadCollection();
})();
</script>
</body>
</html>
